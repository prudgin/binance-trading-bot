from abc import ABCMeta, abstractmethod
import collections
import mplfinance as mpf
import pandas as pd
import numpy as np
import talib

import helper_functions as hlp
import indicators


class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")


class EMAStrategy(Strategy):
    """
    This is an extremely simple strategy
    """

    def __init__(self, events, n, max_buffer_size):
        """
        Initialises the EMA strategy.
        """
        self.events = events
        self.n = n
        self.buffer = collections.deque(maxlen=max_buffer_size)

    def calculate_signals(self, buffered_data: collections.deque):
        # here we suppose that feed_data is indexed by time and uniform. Need to assert this.
        feed_data = list(buffered_data)  # ve have a list of dicts now

        alpha = 2 / (self.n + 1)

        if not self.buffer:
            last = 0
        else:
            last = self.buffer[-1]['open_time']


        #  most of the times feed_data is only 1 bar ahead, check it
        if ((len(feed_data) >= 2 and len(self.buffer) >= 1) and
                feed_data[-2]['open_time'] == self.buffer[-1]['open_time']):
            ema = alpha * feed_data[-1]['close'] + (1 - alpha) * self.buffer[-1]['ema']
            self.buffer.append({
                'open_time': feed_data[-1]['open_time'],
                'ema': ema
            })
        else:
            #  self.buffer is more than 1 block behind feed_data, need to iterate
            for bar in feed_data:
                if bar['open_time'] > last:
                    if last == 0:
                        ema = bar['close']
                    else:
                        ema = alpha * bar['close'] + (1 - alpha) * self.buffer[-1]['ema']
                    self.buffer.append({
                        'open_time': bar['open_time'],
                        'ema': ema
                    })

        if len(self.buffer) > 4:

            tal_ema = talib.EMA(np.asarray([float(i['close']) for i in feed_data]), timeperiod=self.n)

            tal_ema = pd.Series(np.nan_to_num(tal_ema))

            plot_df = pd.DataFrame(self.buffer)[['open_time', 'ema']].copy(deep=True)
            plot_df['open_time'] = pd.to_datetime(plot_df['open_time'], unit='ms')
            plot_df['talib'] = tal_ema
            plot_df = plot_df.set_index('open_time')
            plot_df = plot_df.astype('float')
            plot_df = plot_df[4:]

            ap = mpf.make_addplot(plot_df[['ema', 'talib']])

            prepared = hlp.prepare_df_for_plotting(pd.DataFrame(feed_data))[4:]
            mpf.plot(prepared, type='candle', addplot=ap)


            print(self.buffer[-1]['ema'])
            print(list(tal_ema)[-1])
